# Задание 4. Проектирование продажи ОСАГО

## Проработка реализации:

1. Схема с решением в файле InsureTech_C4_сontainer-diagram_osago.drawio.xml 
Модуль будем писать на том же стеке, как и ins-product-aggregator. Модули по общей функциональности похожи и разработчики смогут позаимствовать часть решений. Для взаимодействия с core-app будет использоваться кластер Kafka. Это удобно, так как в случае отправки запроса на создание заявки на ОСАГО, мы сможем считывать из очереди информацию о ее создании и не ждать ответа. При получении результатов от страховых компаний, мы сможем считывать предложения по факту получения информации, не дожидаясь окончания опроса всех компаний. 
Для взаимодействия osago-aggregator со страховыми компаниями так же используем Apache Kafka + Kafka Connect. Это позволит не терять ответы по факту оформления страховки и получать предложения по факту их предоставления.
2. На мой взгляд сервису osago-aggregator база данных не потребуется, так как он является промежуточным и его задача собрать данные в разных форматах и сконвертировать в формат понятный core-app. После передачи данные будут сохранены в core-db. Думаю для osago-aggregator достаточно будет хранения данных в оперативной памяти. В случае непредвиденного падения, сервис снова возьмет данные из очередей, которые Kafka сохраняет, и быстро возобновит работу. Для предотвращения сбоев и высоких нагрузок, сервис будет масштабироваться при помощи Kubernates.
3. и 4. Для взаимодействия с core-app предлагаю использовать брокера сообщений, в отличие от REST API он позволит сразу же получать/отправлять данные по факту их поступления без переводческих опросов конечных точек.
5. и 6. Взаимодействие между веб-сервисом и core-app будет осуществляется при помощи нескольких соединений. Для создания заявок на оформлении страховок, заполнения данных и подобных случаев не требуется быстрый ответ сервера, поэтому будем использовать REST. Для случаев, когда мы получаем агрегированные данные по факту их поступления, нам необходимо постоянно обновлять интерфейс, чтобы наиболее быстро их отображать. Тут лучше подойдет Websocket. При уходе со страницы просмотра агрегированных данных соединение обязательно закрываем.
7. Я бы применил паттерн отказоустойчивости Circuit Breaker при обращении к внешним системам, чтобы в случае отказа этих систем, мы не тратили ресурсы на отправку запросов и сообщений. Паттерн Rate Limiter я использовал для подключений сервиса сторонних партнеров. Анализировал RPS в разрезе партнеров и ограничивал тех, кто нарушает SLA.
8. Так как сервисы развернуты в нескольких экземплярах, на всех этапах взаимодействия очередей для каждого сообщения должен быть уникальный ключ, чтобы при добавлении в базу не было дублирования информации. Все обработанные сообщения фиксируются и при получении нового сообщения мы анализируем список принятых сообщений и если оно обработано, то игнорируем повторную обработку. 
